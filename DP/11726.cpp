#include <iostream>

using namespace std;

void fastIO()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
}

// 2*N의 크기의 공간에서 2*1, 1*2의 사각형을 최대로 놓는 문제.
// 이런 문제는 완전탐색으로 한다면 경우의 수가 엄청 많다는 것을 알 수 있다.
// 완전탐색이 어려울 경우 DP / Greedy로 생각하기 좋은데 이 문제는 DP의 대표적인 문제.
// DP를 풀 때 점화식을 세우는게 좋다.
// dp[i] = 2*i의 크기에서 제일 많이 배치할 수 있는 경우의 수.
// 이런 문제의 특이사항은 큰 문제를 작은 문제로 나눌 수 있다는 점이다.
// N이 10이라면 N이 10일 때까지를 구하여야 하는데, 10까지 구할 때 3~10의 dp[i]값이 만들어지는데
// 이때 dp[5]는 2*5사이즈에서의 최대 경우의수를 담고 있다.
// 이런식으로 큰 문제를 작은문제로 나눌 수 있고, 작은 문제에서 큰 문제로 갈 때는 일정한 규칙이 있어서 그 규칙을 찾으면 된다.
// 이 문제같은 경우는 그려보면 알 수 있다.
// dp[i]에서 dp[i+1]로 확장될 경우에는 세로 사각형만 넣을 수 있다.
// dp[i]에서 Dp[i+2]로 확장될 경우에는 세로사각형 2개, 가로 사각형 2개만 넣을 수 있다.
// dp[i]에서 dp[i+3]로 확장될 경우에는 dp[i+1]와 연결되어있다는 걸 생각할 수 있고
// 이걸 조금 더 생각해보면 dp[i+2] = dp[i-1] + dp[i-2]의 점화식을 도출할 수 있다.
void solve()
{
    int N;
    int dp[1001];
    cin >> N;

    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= N; i++)
    {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 10007;
    }

    cout << dp[N];
}

int main()
{
    fastIO();
    solve();
}